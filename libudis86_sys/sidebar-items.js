initSidebarItems({"enum":[["ud_mnemonic_code",""],["ud_table_type",""],["ud_type",""]],"fn":[["ud_decode","Returns the number of bytes decoded."],["ud_disassemble","Disassembles the next instruction in the input stream. Returns the number of bytes disassembled. A 0 indicates end of input. Note, to restart disassembly after the end of input, you must call one of the input setting functions with a new source of input."],["ud_get_user_opaque_data","Returns any pointer associated with the udis86 object, using the `ud_set_user_opaque_data` function."],["ud_init","Initializes an instance."],["ud_input_end","Test for end of input. You can use this function to test if udis86 has exhausted the input."],["ud_input_skip","Skips ahead n number of bytes in the input stream."],["ud_insn_asm","If the syntax is specified, returns pointer to the character string holding assembly language representation of the disassembled instruction."],["ud_insn_hex","Returns pointer to a character string holding the hexadecimal representation of the disassembled bytes."],["ud_insn_len","Returns the number of bytes disassembled."],["ud_insn_mnemonic","Returns the instruction mnemonic in the form of an enumerated constant (`ud_mnemonic_code`). As a convention all mnemonic constants are composed by prefixing standard instruction mnemonics with `UD_I`. For example, the enumerations for mov, xor and jmp are `UD_Imov`, `UD_Ixor`, and `UD_Ijmp`, respectively."],["ud_insn_off","Returns the offset of the disassembled instruction in terms of the program counter value specified initially."],["ud_insn_opr","Returns a reference (`ud_operand`) to the nth (starting with 0) operand of the instruction. If the instruction does not have such an operand, the function returns `null`."],["ud_insn_ptr","Returns pointer to the buffer holding the instruction bytes. Use `ud_insn_len` to determine the size of this buffer."],["ud_lookup_mnemonic","Returns a pointer to a character string corresponding to the given mnemonic code. Returns a `null` if the code is invalid."],["ud_opr_is_gpr","Returns true if the operand uses a general purpose register."],["ud_opr_is_sreg","Returns true if the operand uses a segment register."],["ud_set_asm_buffer","Sets a custom assembler output buffer."],["ud_set_input_buffer","Sets the input source for the library to a buffer of size bytes."],["ud_set_input_file","Sets the input source to a file pointed to by a given standard library FILE pointer. Note that libudis86 does not perform any checks, and assumes that the file pointer is properly initialized and open for reading."],["ud_set_input_hook","Sets a pointer to a function, to callback for input. The callback is invoked each time libudis86 needs the next byte in the input stream. To single end-of-input, this callback must return the constant UD_EOI."],["ud_set_mode","Sets the mode of disassembly. Possible values are 16, 32, and 64. By default, the library works in 32bit mode."],["ud_set_pc","Sets the program counter (IP/EIP/RIP). This changes the offset of the assembly output generated, with direct effect on branch instructions."],["ud_set_sym_resolver","Sets a symbol resolver for relative targets used in the translation phase."],["ud_set_syntax","Sets the function that translates the intermediate decode information to a human readable form. There are two inbuilt translators,"],["ud_set_user_opaque_data","Associates a pointer with the udis86 object to be retrieved and used in client functions, such as the input hook callback function."],["ud_set_vendor","Sets the vendor of whose instruction to choose from. This is only useful for selecting the VMX or SVM instruction sets at which point INTEL and AMD have diverged significantly. At a later stage, support for a more granular selection of instruction sets maybe added."],["ud_translate_att","Translator for the AT&T syntax."],["ud_translate_intel","Translator for the Intel syntax."]],"static":[["ud_mnemonics_str",""]],"struct":[["ud",""],["ud_lval_ptr",""],["ud_operand",""]],"union":[["ud_lval",""]]});