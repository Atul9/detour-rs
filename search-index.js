var searchIndex = {};
searchIndex["detour"] = {"doc":"A cross-platform detour library written in Rust.","items":[[3,"GenericDetour","detour","A type-safe wrapper around RawDetour.  ",null,null],[3,"RawDetour","","A type-less detour.",null,null],[3,"StaticDetourController","","An instantiator for StaticDetour.",null,null],[3,"StaticDetour","","A type-safe static detour.",null,null],[0,"error","","Error types and utilities.",null,null],[3,"Error","detour::error","The Error type.",null,null],[12,"0","","The kind of the error.",0,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",1,null],[13,"RegionFailure","","",1,null],[13,"AllocateFailure","","",1,null],[13,"AlreadyExisting","","A static detour has already been initialized",1,null],[13,"InvalidCode","","The address does not contain valid instructions.",1,null],[13,"NoPatchArea","","The address has no available area for patching.",1,null],[13,"NotExecutable","","The address is not executable memory.",1,null],[13,"OutOfMemory","","The system is out of executable memory.",1,null],[13,"UnsupportedLoop","","The address contains an external loop.",1,null],[13,"UnsupportedRelativeBranch","","The address contains an unsupported relative branch.",1,null],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"ResultExt","","Additional methods for `Result`, for easy interaction with this crate.",null,null],[10,"chain_err","","If the `Result` is an `Err` then `chain_err` evaluates the closure, which returns some type that can be converted to `ErrorKind`, boxes the original error to store as the cause, then returns a new error containing the original error.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",0,{"inputs":[{"name":"errorkind"},{"name":"state"}],"output":{"name":"error"}}],[11,"from_kind","","",0,null],[11,"with_chain","","",0,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"self"}}],[11,"kind","","",0,null],[11,"iter","","",0,{"inputs":[{"name":"self"}],"output":{"name":"errorchainiter"}}],[11,"backtrace","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"extract_backtrace","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",0,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",0,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"error"}}],[11,"kind","","Returns the kind of the error.",0,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","Iterates over the error chain.",0,{"inputs":[{"name":"self"}],"output":{"name":"errorchainiter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"maperror"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"deref","","",0,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","A string describing the error kind.",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",1,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","detour","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new hook given a target function and a compatible detour function.",3,{"inputs":[{"name":"t"},{"name":"d"}],"output":{"name":"result"}}],[11,"toggle","","",3,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_enabled","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"trampoline","","",3,null],[11,"new","","Constructs a new inline detour patcher.",4,null],[11,"toggle","","",4,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_enabled","","",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"trampoline","","",4,null],[11,"drop","","Disables the detour, if enabled.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","Output whether the detour is enabled or not.",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"initialize","","Creates a StaticDetour initialized with a target and a closure.",5,{"inputs":[{"name":"self"},{"name":"t"},{"name":"c"}],"output":{"name":"result"}}],[11,"get","","Returns a reference to the underlying detour.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"set_detour","","Changes the detour, regardless of whether the target is hooked or not.",6,{"inputs":[{"name":"self"},{"name":"c"}],"output":null}],[11,"drop","","Removes the detour and frees the controller for new initializations.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",6,{"inputs":[{"name":"self"}],"output":{"name":"genericdetour"}}],[11,"deref_mut","","",6,{"inputs":[{"name":"self"}],"output":{"name":"genericdetour"}}],[8,"Detour","","Generic trait exposing functionality shared between all detours.",null,null],[10,"toggle","","Enables or disables the detour.",7,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"enable","","Enables the detour.",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"disable","","Disables the detour",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"is_enabled","","Returns whether the detour is enabled or not.",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"trampoline","","Returns a reference to the generated trampoline.",7,null],[8,"Function","","Trait representing a function that can be used as a target or detour for detouring.",null,null],[16,"Arguments","","The argument types as a tuple.",8,null],[16,"Output","","The return type.",8,null],[10,"from_ptr","","Constructs a `Function` from an untyped pointer.",8,null],[10,"to_ptr","","Returns an untyped pointer for this function.",8,null],[8,"HookableWith","","Trait indicating that `Self` can be detoured by the given function `D`.",null,null],[14,"static_detours","","A macro for defining type-safe detours.",null,null],[11,"enable","","Enables the detour.",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"disable","","Disables the detour",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}]],"paths":[[3,"Error"],[4,"ErrorKind"],[8,"ResultExt"],[3,"GenericDetour"],[3,"RawDetour"],[3,"StaticDetourController"],[3,"StaticDetour"],[8,"Detour"],[8,"Function"]]};
initSearch(searchIndex);
